  这里我们不讨论存储过程中的事务过程 我们只说关于事务锁的起因和分类

一、我们为什么要用事务锁 因为我们可能在操作数据库数据时遇到以下一些情况

    1、更新丢失：当多个用户同时对一条数据进行更新时，必定会造成数据覆盖，从而读写异常
    2、不可重复读：当一个用户多次读取一条数据，而另一个用户同时在更新这一条数据，会导致第一个用户前后读取的数据不统一
    3、脏读：当一个事务在读取数据的结果集时有另一个事务在更新数据，如果第二个事务更新没有完成，那么会造成第一个事务读的结果集一部分更新后和一部分未更新的
    4、幻读：当一个事务在读取数据的结果集时有另一个事务在增删数据，当第一个事务再次查询结果集时，会发现数据的丢失或新增

由此 锁定就由此诞生，他的存在就是为了让一个事务对数据块进行操作时，阻止其他事务插足这些数据块  这个就是所谓的锁定

二、锁的种类 针对不同的情况大致分为六种
    1、共享锁(S 读锁)：可以并发的读取读取数据，但是不可以修改数据。也就是说当数据资源上存在共享锁时，所有的事务都不可以对该数据进行修改，直到锁释放
    2、排它锁(X 独占锁 写锁)：如果对资源进行增删改时，不许其他的事务对该资源进行操作，直到释放，防止多重操作
    3、更新锁(U)：防止出现死锁的锁模式，当事务对资源进行先读在修改的情况下，可能会出现死锁，而使用更新锁就能避免这种情况，资源的更新锁一次只会
    分配给一个事务，如果对资源进行修改，更新锁就会变为排它锁，否则变为共享锁
    4、意向锁：意向锁：SQL Server需要在层次结构中的底层资源上（如行，列）获取共享锁，排它锁，更新锁。例如表级放置了意向共享锁，就表示事务要
    对表的页或行上使用共享锁。在表的某一行上上放置意向锁，可以防止其它事务获取其它不兼容的的锁。意向锁可以提高性能，因为数据引擎不需要检测资
    源的每一列每一行，就能判断是否可以获取到该资源的兼容锁。意向锁包括三种类型：意向共享锁（IS），意向排他锁（IX），意向排他共享锁（SIX）。
    5、架构锁：防止修改表结构时，并发访问的锁
    6、大容量更新锁：允许多个线程将大容量的数据插入到同一张表中，在加载的过程中 不允许访问

三、锁的兼容性

                    现有的授权模式
    请求的模式          IS                       S           U            IX           SIX          X

    意向共享 (IS)       是                       是          是		      是           是           否

    共享 (S)            是                       是          是           否           否           否

    更新 (U)			    是						 是			 否           否		       否			否

    意向排他 (IX)       是						 否			 否			  是		       否           否

    意向排他共享 (SIX)  是						 否			 否			  否		       否           否

    排他 (X)            否                       否           否           否           否           否

四、死锁
    1、举个栗子：
        begin tran       #开启一个事务(起个简称 A 吧 好叙述)
            update table set num = 1  where ...  #更新一个table的字段
            waitfor  delay  '0:0:5'              #等待5秒
            update table_1 set mac = 1 where ...  #更新一个table_1的字段
        commit tran      #提交事务



        begin tran       #再开启一个事务(简称 B )
            update table_1 set mac = 2  where ...  #更新一个table_1的字段
            waitfor  delay  '0:0:5'              #等待5秒
            update table set num = 2 where ...  #更新一个table的字段
        commit tran      #提交事务

        第一个事务运行后 五秒内运行第二个事务就会产生死锁 流程：
            1、A事务，更新table表  获取table表的排它锁，然后等待...(5秒)
            2、B事务，更新table_1表，获取table_1表的排它锁，然后等待...(5秒)
            3、五秒后
            4、A事务要更新table_1表，请求获得table_1的排它锁 等待...
            5、B事务要更新table表，请求获得table的排它锁 等待...
        就是这样 两个事务都在等待对方释放锁 就造成了资源读写拥挤阻塞的情况  就称为死锁现象，也叫阻塞

    2、方案
        就数据库而言，是不可能这样无限期的等待下去的，数据库的搜索引擎会定期检测这种状况，如有发现，会立马选择一个事务作为牺牲品，牺牲
        事务，回滚数据。那么谁作为牺牲品呢？死锁处理的优先级别为 low<normal<high，不指定的情况下默认为normal，牺牲品为随机。如果指定，
        牺牲品为级别低的。还可以使用数字来处理标识级别：-10到-5为low，-5为normal，-5到10为high。
        当然这个也是认为可控的：set deadlock_priority  <级别>

    3、减少死锁，提高性能
        a、按照同一顺序访问数据库资源，上述例子就不会发生死锁啦
        b、保持是事务的简短，尽量不要让一个事务处理过于复杂的读写操作。事务过于复杂，占用资源会增多，处理时间增长，容易与其它事务冲突，提升死锁概率。
        c、尽量不要在事务中要求用户响应，比如修改新增数据之后在完成整个事务的提交，这样延长事务占用资源的时间，也会提升死锁概率。
        d、尽量减少数据库的并发量。
        e、尽可能使用分区表，分区视图，把数据放置在不同的磁盘和文件组中，分散访问保存在不同分区的数据，减少因为表中放置锁而造成的其它事务长时间等待。
        f、避免占用时间很长并且关系表复杂的数据操作。
        g、使用较低的隔离级别，使用较低的隔离级别比使用较高的隔离级别持有共享锁的时间更短。这样就减少了锁争用。

五、锁的超时时间

    发生死锁的时候，数据库引擎会自动检测死锁，解决问题，然而这样子是很被动，只能在发生死锁后，等待处理。
    然而我们也可以主动出击，设置锁超时时间，一旦资源被锁定阻塞，超过设置的锁定时间，阻塞语句自动取消，释放资源，报1222错误。

    好东西一般都具有两面性，调优的同时，也有他的不足之处，那就是一旦超过时间，语句取消，释放资源，但是当前报错事务，不会回滚，会造成数据错误，
    你需要在程序中捕获1222错误，用程序处理当前事务的逻辑，使数据正确


五、为事务设置隔离级别
    1、所谓隔离级别呢，就是并发事务对于同一资源读取的深度层次
        a、read uncommitted：这种隔离程度是最低的，可以读到一个事务正在处理还未commit的数据，这种级别的隔离我们叫做脏读
        b、read committed：这个级别是默认选项，不能脏读，但是可以修改。A事务多次读取一个数据，同时B事务修改了它，会导致A事务读取的前后内容差异
        c、repeatable read：不脏读，不修改事务处理前的数据， 但是会幻读
        d、snapshot：指定事务在开始的时候，就获得了已经提交数据的快照，因此当前事务只能看到事务开始之前对数据所做的修改。
        f、最高事务隔离级别，只能看到事务处理之前的数据。 但是，由于事务是串行执行，所以效率会大大下降，应用程序的性能会急剧降低。如果没有特别重要的情景，一般都不会使用Serializable隔离级别

    在MySQL中，如果使用InnoDB，默认的隔离级别是Repeatable Read


